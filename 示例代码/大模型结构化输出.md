当您需要模型像程序一样输出标准格式 (这里主要指 JSON 格式) 而不是自然语言，方便工具进行标准化处理或展示时，可以使用模式化输出能力。

要启用该能力，需在请求时配置 `response_format` 对象，来指定模型输出 JSON 格式，甚至通过定义 JSON 结构，进一步定义模型输出哪些字段信息。

与通过提示词控制模型输出 JSON 格式的方法 (不推荐) 相比，使用结构化输出能力有以下好处：

*   输出更可靠：输出结构始终符合预期数据类型，包括结构中字段层级、名称、类型、顺序等，不必担心丢失必要的字段或生成幻觉的枚举值等。
*   使用更加简单：使用 API 字段来定义，提示词可更加简单，无需在提示词中反复强调或使用强烈措辞。

## 支持的模型

请参见[结构化输出](https://www.volcengine.com/docs/82379/1269376)。

## API 文档

结构化输出 API 字段说明见[对话(Chat) API](https://www.volcengine.com/docs/82379/109946)。

## 快速开始

``` python
// Python

from volcenginesdkarkruntime import Ark
import os
from pydantic import BaseModel  # 用于定义响应解析模型

# 初始化方舟SDK客户端
client = Ark(
    # 从环境变量获取方舟API Key（需提前设置环境变量）
    api_key=os.environ.get("ARK_API_KEY"),
)

# 定义分步解析模型（对应业务场景的结构化响应）
class Step(BaseModel):
    explanation: str  # 步骤说明
    output: str       # 步骤计算结果

# 定义最终响应模型（包含分步过程和最终答案）
class MathResponse(BaseModel):
    steps: list[Step]       # 解题步骤列表
    final_answer: str       # 最终答案

# 调用方舟模型生成响应（自动解析为指定模型）
completion = client.beta.chat.completions.parse(
    model="doubao-seed-1.6-250615",  # 具体模型需替换为实际可用模型
    messages=[
        {"role": "system", "content": "你是一位数学辅导老师，需详细展示解题步骤"},
        {"role": "user", "content": "用中文解方程组：8x + 9 = 32 和 x + y = 1"}
    ],
    response_format=MathResponse,  # 指定响应解析模型
    extra_body={
         "thinking": {
             "type": "disabled" # 不使用深度思考能力
             # "type": "enabled" # 使用深度思考能力
         }
     }
)

# 提取解析后的结构化响应
resp = completion.choices[0].message.parsed

# 打印格式化的JSON结果
print(resp.model_dump_json(indent=2))
```



``` json
{
  "steps": [
    {
      "explanation": "解第一个方程8x + 9 = 32，先将等式两边同时减去9，得到8x = 32 - 9",
      "output": "8x = 23"
    },
    {
      "explanation": "然后等式两边同时除以8，求出x的值",
      "output": "x = 23/8"
    },
    {
      "explanation": "将x = 23/8代入第二个方程x + y = 1，求解y，即y = 1 - x",
      "output": "y = 1 - 23/8"
    },
    {
      "explanation": "计算1 - 23/8，通分后得到(8 - 23)/8",
      "output": "y = -15/8"
    }
  ],
  "final_answer": "x = 23/8，y = -15/8"
}

```

## 模式对比: `json_schema` 与 `json_mode`

格式化输出可以选择不同类型 (type)，包括 `json_schema`、`json_mode`、`text`。除 `text` 是让模型使用自然语言进行回复，`json_schema` 和 `json_mode` 均是控制生成 JSON 格式回答，同时 `json_schema` 是 `json_mode` 的演进版本，以下是他们的异同点。

> 当前 `json_schema` 功能还在beta 测试中，请谨慎评估后再在生产环境使用。

| 结构化输出        | `json_schema`                                                                                                                              | `json_mode`                                                                                                      |
| :---------------- | :----------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------- |
| 生成 JSON 回复    | 是                                                                                                                                         | 是                                                                                                               |
| 可定义 JSON 结构  | 是                                                                                                                                         | 否<br>仅保障回复是合法 JSON                                                                                     |
| 是否推荐          | 是                                                                                                                                         | 否                                                                                                               |
| 支持的模型        | • doubao-seed-1.6-250615<br>• doubao-seed-1.6-flash-250615<br>• doubao-1.5-thinking-vision-pro-250428<br>• deepseek-r1-250528                 | • doubao-seed-1.6-250615<br>• doubao-seed-1.6-flash-250615<br>• doubao-1.5-thinking-vision-pro-250428<br>• deepseek-r1-250528 |
| 严格模式          | 支持<br>通过设置 `strict` 为 `true` 生效。<br>遵循语法见[附1. JSON Schema 语法支持说明](TODO: Link to Appendix 1)，若有不支持的结构会显示报错。 | 不涉及                                                                                                           |
| 配置方式          | ```json<br>...<br>"response_format": {<br>  "type": "json_schema",<br>  "json_schema":{<br>    "name":"my_schema",<br>    "strict": true,<br>    "schema": {...}<br>  }<br>}<br>...<br>``` | ```json<br>...<br>"response_format": {<br>  "type": "json_object"<br>},<br>...<br>```                                |

## 推荐使用步骤

### 1.定义结构

您需要在 schema 字段中定义好模型生成的回复的 JSON 结构，可以参考[快速开始](TODO: Link to Quick Start)的示例。

*   当您需要模型严格按照结构输出时，需配置 `strict` 字段为 `true`。方舟支持的关键字可见[附1. JSON Schema 语法支持说明](TODO: Link to Appendix 1)，如果有明显不支持的定义，方舟会显示报错。
*   当您配置 `strict` 字段为 `false` 或者未配置 `strict` 字段，方舟会生成合法 JSON 结构的内容，同时尽可能参考您定义的结构，不会对语法校验及报错。

> **说明**
>
> *   为了帮助您获得更好的生成质量，下面是定义结构时的一些建议，更多建议见 [附2.结构化生成最佳实践](TODO: Link to Appendix 2):
>     *   忽略结构中的字段名称应该清晰且易于理解。
>     *   为结构中重要字段配置 `title` 和 `description` 属性。
>     *   使用评估工具来帮助确定最适合您期望的结构。
>     *   为防止 JSON 模式与编程语言类型定义不一致，推荐使用语言原生的工具支持，如 Python 可使用 [Pydantic](https://docs.pydantic.dev/latest/)，TypeScript 可使用 [Zod](https://zod.dev/)。
>     *   请注意同级字段的先后顺序，模型输出将根据 `schema` 字段定义的字段顺序数据。

### 2.API 中进行配置 JSON Schema

在 API 中指定结构化输出的模式
```json
// JSON
...,
"response_format": {
  "type": "json_schema",
  "json_schema":{
    "name":"my_schema",
    "strict": true,
    "schema": {...}
  }
},
...
```
完整示例代码见 [快速开始](TODO: Link to Quick Start)。

> **说明**
>
> 请勿与 `frequency_penalty`, `presence_penalty` 等采样参数共同使用，可能会导致模型输出异常。

### 3.处理错误案例

模型输出结构仍然可能包含错误，可能因为输出长度限制、任务复杂度、格式不清晰等。可以尝试调整指令，或将任务进行拆分为更简单子任务。您可以使用方舟的提示词优化工具来帮您优化模型提示词，详细见 [PromptPilot 概述](https://www.volcengine.com/docs/82379/1269375)。

## 附1. JSON Schema 语法支持说明

> **说明**
>
> *   按关键字的作用域分类，JSON Schema 有效关键字全集 https://json-schema.org/understanding-json-schema/keywords
> *   下面支持的关键字代表方舟已支持关键字对应的输出格式约束语义。
> *   方舟会忽略 JSON Schema 规范中没有格式约束语义的关键字。
> *   使用明确不支持的关键字，方舟会显式报错。
> *   请勿与 `frequency_penalty`, `presence_penalty` 等采样参数共同使用，可能会导致模型输出异常。

### Schema 层面公共关键字

*   [`type`](https://json-schema.org/understanding-json-schema/reference/type)
    *   `integer`
    *   `number`
    *   `string`
    *   `boolean`
    *   `null`
    *   `array`
    *   `object`
*   [`$ref`](https://json-schema.org/understanding-json-schema/structuring#ref)
    *   只支持 `#` 开头的本地相对引用
*   [`$defs`](https://json-schema.org/understanding-json-schema/structuring#defs)
*   [`const`](https://json-schema.org/understanding-json-schema/reference/generic#const)
*   [`enum`](https://json-schema.org/understanding-json-schema/reference/generic#enum)
*   [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyof)
*   [`oneOf`](https://json-schema.org/understanding-json-schema/reference/combining#oneof)
    *   不严格保证 exactly one 语义
*   [`allOf`](https://json-schema.org/understanding-json-schema/reference/combining#allof)
    *   不严格保证 all 语义

### `type` 相关的关键字

*   `"type": "integer"`
    *   [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#minimum)
    *   [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#maximum)
    *   [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#exclusiveminimum)
    *   [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#exclusivemaximum)
        > 以上无法 100% 保证区间语义。
*   `"type": "array"`
    *   [`prefixItems`](https://json-schema.org/understanding-json-schema/reference/array#prefixitems)
    *   [`items`](https://json-schema.org/understanding-json-schema/reference/array#items)
    *   [`unevaluatedItems`](https://json-schema.org/understanding-json-schema/reference/ ইতিহাসের#unevaluateditems)
*   `"type": "object"`
    *   [`properties`](https://json-schema.org/understanding-json-schema/reference/object#properties)
    *   [`required`](https://json-schema.org/understanding-json-schema/reference/object#required)
    *   [`additionalProperties`](https://json-schema.org/understanding-json-schema/reference/object#additionalproperties)
    *   [`unevaluatedProperties`](https://json-schema.org/understanding-json-schema/reference/object#unevaluatedproperties)

## 附2. 结构化生成最佳实践

### json schema 建议

#### 字段命名与描述

字段命名含糊/无描述，导致模型难以判断含义。使用清晰有意义的英文名（如 user_name），并配合 `description` 详细说明字段用途。
错误示例
```json
{
  "type": "object",
  "properties": {
    "v1": {
      "type": "string"
    }
  }
}
```
改进后示例
```json
{
  "type": "object",
  "properties": {
    "user_name": {
      "type": "string",
      "description": "用户的姓名"
    }
  }
}
```

#### 字段类型与结构设计

避免冗余嵌套与不必要复杂化
不过度使用 $ref，结构尽可能一次性展开。无意义的嵌套会增加模型生成难度，提高出错概率。
错误示例
```json
{
  "type": "object",
  "properties": {
    "date": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "日期"
        }
      }
    }
  }
}
```
改进后示例
```json
{
  "type": "object",
  "properties": {
    "date": {
      "type": "string",
      "description": "日期, 格式为 YYYY-MM-DD"
    }
  }
}
```

#### 字段类型要明确、例子需补充

错误示例
```json
{
  "score": {
    "type": "string"
  }
}
```
改进后示例
```json
{
  "score": {
    "type": "integer",
    "description": "成绩, 0到100的整数"
  }
}
```
说明：类型应尽量贴合实际业务。对于数字、布尔值等不能简单用 string 替代。

#### 字段取值与约束设计

明确枚举值与格式
错误示例
```json
{
  "status": {
    "type": "string"
  }
}
```
改进后示例
```json
{
  "status": {
    "type": "string",
    "description": "处理状态, 可为: pending、success 或 failed",
    "enum": ["pending", "success", "failed"]
  }
}
```

#### 结构层级与必填项

所有需要的结构明确 `required`，这样模型会始终输出所有必需字段，格式更规范。
推荐使用 `required` 时，始终加上 `"additionalProperties": false`。
错误示例
```json
{
  "type": "object",
  "properties": {
    "steps": { "type": "array", "items": { "type": "string" } },
    "final_answer": { "type": "string" }
  }
  // 没有 required
}
```
改进后示例
```json
{
  "type": "object",
  "properties": {
    "steps": { "type": "array", "items": { "type": "string" } },
    "final_answer": { "type": "string" }
  },
  "required": ["steps", "final_answer"],
  "additionalProperties": false
}
```

#### 业务语义需清晰，避免歧义

错误示例
```json
{
  "type": "object",
  "properties": {
    "id": { "type": "string", "description": "用户或订单编号" }
  }
}
```
改进后示例
```json
{
  "type": "object",
  "properties": {
    "user_id": { "type": "string", "description": "用户编号" },
    "order_id": { "type": "string", "description": "订单编号" }
  }
}
```

### Prompt 建议

#### 指明任务目标，简洁表达意图

*   只需直接描述实际希望模型完成的任务即可，无须再过多强调“请用 JSON 输出”、“请用如下格式输出”等。
*   不必在 prompt 中重复 schema 结构的信息，避免造成矛盾或冗余。

错误示例
```
Plain
请用如下 JSON 格式输出，并包含字段 steps、final_answer: 8x + 9 = 32, x+y=1。
```
改进后示例
```
Plain
请求解: 8x + 9 = 32, x + y = 1。
```

#### 结合结构化信息写业务内容，而不是格式引导

*   关注“内容本身”，而非“输出形式”。
*   业务描述越具体，LLM 更易给出符合 schema 的内容。

错误示例
```
Plain
请输出一个包含 steps 和 final_answer 字段的 JSON。
```
改进后示例
```
Plain
请一步步推理解答: 8x + 9 = 32, x+y=1, 并写出最终答案。
```
